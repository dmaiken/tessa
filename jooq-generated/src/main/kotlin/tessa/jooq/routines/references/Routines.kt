@file:Suppress("warnings")
/*
 * This file is generated by jOOQ.
 */
package tessa.jooq.routines.references


import org.jooq.Configuration
import org.jooq.Field
import org.jooq.postgres.extensions.types.Ltree

import tessa.jooq.routines.Index1
import tessa.jooq.routines.Index2
import tessa.jooq.routines.Lca1
import tessa.jooq.routines.Lca2
import tessa.jooq.routines.Lca3
import tessa.jooq.routines.Lca4
import tessa.jooq.routines.Lca5
import tessa.jooq.routines.Lca6
import tessa.jooq.routines.Lca7
import tessa.jooq.routines.Lca8
import tessa.jooq.routines.LqueryIn
import tessa.jooq.routines.LqueryOut
import tessa.jooq.routines.LqueryRecv
import tessa.jooq.routines.LquerySend
import tessa.jooq.routines.LtQRegex
import tessa.jooq.routines.LtQRregex
import tessa.jooq.routines.Ltree2text
import tessa.jooq.routines.LtreeAddltree
import tessa.jooq.routines.LtreeAddtext
import tessa.jooq.routines.LtreeCmp
import tessa.jooq.routines.LtreeCompress
import tessa.jooq.routines.LtreeConsistent
import tessa.jooq.routines.LtreeDecompress
import tessa.jooq.routines.LtreeEq
import tessa.jooq.routines.LtreeGe
import tessa.jooq.routines.LtreeGistIn
import tessa.jooq.routines.LtreeGistOptions
import tessa.jooq.routines.LtreeGistOut
import tessa.jooq.routines.LtreeGt
import tessa.jooq.routines.LtreeIn
import tessa.jooq.routines.LtreeIsparent
import tessa.jooq.routines.LtreeLe
import tessa.jooq.routines.LtreeLt
import tessa.jooq.routines.LtreeNe
import tessa.jooq.routines.LtreeOut
import tessa.jooq.routines.LtreePenalty
import tessa.jooq.routines.LtreePicksplit
import tessa.jooq.routines.LtreeRecv
import tessa.jooq.routines.LtreeRisparent
import tessa.jooq.routines.LtreeSame
import tessa.jooq.routines.LtreeSend
import tessa.jooq.routines.LtreeTextadd
import tessa.jooq.routines.LtreeUnion
import tessa.jooq.routines.Ltreeparentsel
import tessa.jooq.routines.LtxtqExec
import tessa.jooq.routines.LtxtqIn
import tessa.jooq.routines.LtxtqOut
import tessa.jooq.routines.LtxtqRecv
import tessa.jooq.routines.LtxtqRexec
import tessa.jooq.routines.LtxtqSend
import tessa.jooq.routines.Nlevel
import tessa.jooq.routines.Subltree
import tessa.jooq.routines.Subpath1
import tessa.jooq.routines.Subpath2
import tessa.jooq.routines.Text2ltree
import tessa.jooq.routines._LtQRegex
import tessa.jooq.routines._LtQRregex
import tessa.jooq.routines._LtqExtractRegex
import tessa.jooq.routines._LtreeCompress
import tessa.jooq.routines._LtreeConsistent
import tessa.jooq.routines._LtreeExtractIsparent
import tessa.jooq.routines._LtreeExtractRisparent
import tessa.jooq.routines._LtreeGistOptions
import tessa.jooq.routines._LtreeIsparent
import tessa.jooq.routines._LtreePenalty
import tessa.jooq.routines._LtreePicksplit
import tessa.jooq.routines._LtreeRIsparent
import tessa.jooq.routines._LtreeRRisparent
import tessa.jooq.routines._LtreeSame
import tessa.jooq.routines._LtreeUnion
import tessa.jooq.routines._LtxtqExec
import tessa.jooq.routines._LtxtqExtractExec
import tessa.jooq.routines._LtxtqRexec



/**
 * Call <code>public._lt_q_regex</code>
 */
fun _LtQRegex(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Array<Any?>?
): Boolean? {
    val f = _LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._lt_q_regex</code> as a field.
 */
fun _LtQRegex(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Array<Any?>?
): Field<Boolean?> {
    val f = _LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._lt_q_regex</code> as a field.
 */
fun _LtQRegex(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Array<Any?>?>
): Field<Boolean?> {
    val f = _LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public._lt_q_rregex</code>
 */
fun _LtQRregex(
      configuration: Configuration
    , __1: Array<Any?>?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Boolean? {
    val f = _LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._lt_q_rregex</code> as a field.
 */
fun _LtQRregex(
      __1: Array<Any?>?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Field<Boolean?> {
    val f = _LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._lt_q_rregex</code> as a field.
 */
fun _LtQRregex(
      __1: Field<Array<Any?>?>
    , __2: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
): Field<Boolean?> {
    val f = _LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtqExtractRegex(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Ltree? {
    val f = _LtqExtractRegex()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtqExtractRegex(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Field<Ltree?> {
    val f = _LtqExtractRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtqExtractRegex(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Any?>
): Field<Ltree?> {
    val f = _LtqExtractRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeCompress(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = _LtreeCompress()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeCompress(
      __1: Any?
): Field<Any?> {
    val f = _LtreeCompress()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeCompress(
      __1: Field<Any?>
): Field<Any?> {
    val f = _LtreeCompress()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeConsistent(
      configuration: Configuration
    , __1: Any?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __3: Short?
    , __4: Long?
    , __5: Any?
): Boolean? {
    val f = _LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeConsistent(
      __1: Any?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __3: Short?
    , __4: Long?
    , __5: Any?
): Field<Boolean?> {
    val f = _LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeConsistent(
      __1: Field<Any?>
    , __2: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __3: Field<Short?>
    , __4: Field<Long?>
    , __5: Field<Any?>
): Field<Boolean?> {
    val f = _LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}

/**
 * Call <code>public._ltree_extract_isparent</code>
 */
fun _LtreeExtractIsparent(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Ltree? {
    val f = _LtreeExtractIsparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._ltree_extract_isparent</code> as a field.
 */
fun _LtreeExtractIsparent(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Field<Ltree?> {
    val f = _LtreeExtractIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._ltree_extract_isparent</code> as a field.
 */
fun _LtreeExtractIsparent(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Ltree?>
): Field<Ltree?> {
    val f = _LtreeExtractIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public._ltree_extract_risparent</code>
 */
fun _LtreeExtractRisparent(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Ltree? {
    val f = _LtreeExtractRisparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._ltree_extract_risparent</code> as a field.
 */
fun _LtreeExtractRisparent(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Field<Ltree?> {
    val f = _LtreeExtractRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._ltree_extract_risparent</code> as a field.
 */
fun _LtreeExtractRisparent(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Ltree?>
): Field<Ltree?> {
    val f = _LtreeExtractRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeGistOptions(
      configuration: Configuration
    , __1: Any?
): Unit {
    val p = _LtreeGistOptions()
    p.set__1(__1)

    p.execute(configuration)
}

/**
 * Call <code>public._ltree_isparent</code>
 */
fun _LtreeIsparent(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Boolean? {
    val f = _LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._ltree_isparent</code> as a field.
 */
fun _LtreeIsparent(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Ltree?
): Field<Boolean?> {
    val f = _LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._ltree_isparent</code> as a field.
 */
fun _LtreeIsparent(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = _LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePenalty(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
    , __3: Any?
): Any? {
    val f = _LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePenalty(
      __1: Any?
    , __2: Any?
    , __3: Any?
): Field<Any?> {
    val f = _LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePenalty(
      __1: Field<Any?>
    , __2: Field<Any?>
    , __3: Field<Any?>
): Field<Any?> {
    val f = _LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePicksplit(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
): Any? {
    val f = _LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePicksplit(
      __1: Any?
    , __2: Any?
): Field<Any?> {
    val f = _LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreePicksplit(
      __1: Field<Any?>
    , __2: Field<Any?>
): Field<Any?> {
    val f = _LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public._ltree_r_isparent</code>
 */
fun _LtreeRIsparent(
      configuration: Configuration
    , __1: Ltree?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Boolean? {
    val f = _LtreeRIsparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._ltree_r_isparent</code> as a field.
 */
fun _LtreeRIsparent(
      __1: Ltree?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Field<Boolean?> {
    val f = _LtreeRIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._ltree_r_isparent</code> as a field.
 */
fun _LtreeRIsparent(
      __1: Field<Ltree?>
    , __2: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
): Field<Boolean?> {
    val f = _LtreeRIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public._ltree_r_risparent</code>
 */
fun _LtreeRRisparent(
      configuration: Configuration
    , __1: Ltree?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Boolean? {
    val f = _LtreeRRisparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public._ltree_r_risparent</code> as a field.
 */
fun _LtreeRRisparent(
      __1: Ltree?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Field<Boolean?> {
    val f = _LtreeRRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public._ltree_r_risparent</code> as a field.
 */
fun _LtreeRRisparent(
      __1: Field<Ltree?>
    , __2: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
): Field<Boolean?> {
    val f = _LtreeRRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeSame(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
    , __3: Any?
): Any? {
    val f = _LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeSame(
      __1: Any?
    , __2: Any?
    , __3: Any?
): Field<Any?> {
    val f = _LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeSame(
      __1: Field<Any?>
    , __2: Field<Any?>
    , __3: Field<Any?>
): Field<Any?> {
    val f = _LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeUnion(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
): Any? {
    val f = _LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeUnion(
      __1: Any?
    , __2: Any?
): Field<Any?> {
    val f = _LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtreeUnion(
      __1: Field<Any?>
    , __2: Field<Any?>
): Field<Any?> {
    val f = _LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExec(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Boolean? {
    val f = _LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExec(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Field<Boolean?> {
    val f = _LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExec(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Any?>
): Field<Boolean?> {
    val f = _LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExtractExec(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Ltree? {
    val f = _LtxtqExtractExec()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExtractExec(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
    , __2: Any?
): Field<Ltree?> {
    val f = _LtxtqExtractExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqExtractExec(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
    , __2: Field<Any?>
): Field<Ltree?> {
    val f = _LtxtqExtractExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqRexec(
      configuration: Configuration
    , __1: Any?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Boolean? {
    val f = _LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqRexec(
      __1: Any?
    , __2: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Field<Boolean?> {
    val f = _LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun _LtxtqRexec(
      __1: Field<Any?>
    , __2: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
): Field<Boolean?> {
    val f = _LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.index</code>
 */
fun index1(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Int? {
    val f = Index1()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.index</code> as a field.
 */
fun index1(
      __1: Ltree?
    , __2: Ltree?
): Field<Int?> {
    val f = Index1()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.index</code> as a field.
 */
fun index1(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Int?> {
    val f = Index1()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.index</code>
 */
fun index2(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Int?
): Int? {
    val f = Index2()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.index</code> as a field.
 */
fun index2(
      __1: Ltree?
    , __2: Ltree?
    , __3: Int?
): Field<Int?> {
    val f = Index2()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Get <code>public.index</code> as a field.
 */
fun index2(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Int?>
): Field<Int?> {
    val f = Index2()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca1(
      configuration: Configuration
    , __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Ltree? {
    val f = Lca1()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca1(
      __1: Array<org.jooq.postgres.extensions.types.Ltree?>?
): Field<Ltree?> {
    val f = Lca1()
    f.set__1(__1)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca1(
      __1: Field<Array<org.jooq.postgres.extensions.types.Ltree?>?>
): Field<Ltree?> {
    val f = Lca1()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca2(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Ltree? {
    val f = Lca2()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca2(
      __1: Ltree?
    , __2: Ltree?
): Field<Ltree?> {
    val f = Lca2()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca2(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca2()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca3(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
): Ltree? {
    val f = Lca3()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca3(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
): Field<Ltree?> {
    val f = Lca3()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca3(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca3()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca4(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
): Ltree? {
    val f = Lca4()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca4(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
): Field<Ltree?> {
    val f = Lca4()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca4(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
    , __4: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca4()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca5(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
): Ltree? {
    val f = Lca5()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca5(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
): Field<Ltree?> {
    val f = Lca5()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca5(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
    , __4: Field<Ltree?>
    , __5: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca5()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca6(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
): Ltree? {
    val f = Lca6()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca6(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
): Field<Ltree?> {
    val f = Lca6()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca6(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
    , __4: Field<Ltree?>
    , __5: Field<Ltree?>
    , __6: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca6()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca7(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
    , __7: Ltree?
): Ltree? {
    val f = Lca7()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca7(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
    , __7: Ltree?
): Field<Ltree?> {
    val f = Lca7()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca7(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
    , __4: Field<Ltree?>
    , __5: Field<Ltree?>
    , __6: Field<Ltree?>
    , __7: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca7()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)

    return f.asField()
}

/**
 * Call <code>public.lca</code>
 */
fun lca8(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
    , __7: Ltree?
    , __8: Ltree?
): Ltree? {
    val f = Lca8()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)
    f.set__8(__8)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca8(
      __1: Ltree?
    , __2: Ltree?
    , __3: Ltree?
    , __4: Ltree?
    , __5: Ltree?
    , __6: Ltree?
    , __7: Ltree?
    , __8: Ltree?
): Field<Ltree?> {
    val f = Lca8()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)
    f.set__8(__8)

    return f.asField()
}

/**
 * Get <code>public.lca</code> as a field.
 */
fun lca8(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
    , __3: Field<Ltree?>
    , __4: Field<Ltree?>
    , __5: Field<Ltree?>
    , __6: Field<Ltree?>
    , __7: Field<Ltree?>
    , __8: Field<Ltree?>
): Field<Ltree?> {
    val f = Lca8()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)
    f.set__6(__6)
    f.set__7(__7)
    f.set__8(__8)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryIn(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LqueryIn()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryIn(
      __1: Any?
): Field<Any?> {
    val f = LqueryIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryIn(
      __1: Field<Any?>
): Field<Any?> {
    val f = LqueryIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryOut(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LqueryOut()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryOut(
      __1: Any?
): Field<Any?> {
    val f = LqueryOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryOut(
      __1: Field<Any?>
): Field<Any?> {
    val f = LqueryOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryRecv(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LqueryRecv()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryRecv(
      __1: Any?
): Field<Any?> {
    val f = LqueryRecv()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lqueryRecv(
      __1: Field<Any?>
): Field<Any?> {
    val f = LqueryRecv()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lquerySend(
      configuration: Configuration
    , __1: Any?
): ByteArray? {
    val f = LquerySend()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lquerySend(
      __1: Any?
): Field<ByteArray?> {
    val f = LquerySend()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun lquerySend(
      __1: Field<Any?>
): Field<ByteArray?> {
    val f = LquerySend()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.lt_q_regex</code>
 */
fun ltQRegex(
      configuration: Configuration
    , __1: Ltree?
    , __2: Array<Any?>?
): Boolean? {
    val f = LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lt_q_regex</code> as a field.
 */
fun ltQRegex(
      __1: Ltree?
    , __2: Array<Any?>?
): Field<Boolean?> {
    val f = LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.lt_q_regex</code> as a field.
 */
fun ltQRegex(
      __1: Field<Ltree?>
    , __2: Field<Array<Any?>?>
): Field<Boolean?> {
    val f = LtQRegex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.lt_q_rregex</code>
 */
fun ltQRregex(
      configuration: Configuration
    , __1: Array<Any?>?
    , __2: Ltree?
): Boolean? {
    val f = LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.lt_q_rregex</code> as a field.
 */
fun ltQRregex(
      __1: Array<Any?>?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.lt_q_rregex</code> as a field.
 */
fun ltQRregex(
      __1: Field<Array<Any?>?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtQRregex()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree2text</code>
 */
fun ltree2text(
      configuration: Configuration
    , __1: Ltree?
): String? {
    val f = Ltree2text()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree2text</code> as a field.
 */
fun ltree2text(
      __1: Ltree?
): Field<String?> {
    val f = Ltree2text()
    f.set__1(__1)

    return f.asField()
}

/**
 * Get <code>public.ltree2text</code> as a field.
 */
fun ltree2text(
      __1: Field<Ltree?>
): Field<String?> {
    val f = Ltree2text()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_addltree</code>
 */
fun ltreeAddltree(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Ltree? {
    val f = LtreeAddltree()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_addltree</code> as a field.
 */
fun ltreeAddltree(
      __1: Ltree?
    , __2: Ltree?
): Field<Ltree?> {
    val f = LtreeAddltree()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_addltree</code> as a field.
 */
fun ltreeAddltree(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Ltree?> {
    val f = LtreeAddltree()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_addtext</code>
 */
fun ltreeAddtext(
      configuration: Configuration
    , __1: Ltree?
    , __2: String?
): Ltree? {
    val f = LtreeAddtext()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_addtext</code> as a field.
 */
fun ltreeAddtext(
      __1: Ltree?
    , __2: String?
): Field<Ltree?> {
    val f = LtreeAddtext()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_addtext</code> as a field.
 */
fun ltreeAddtext(
      __1: Field<Ltree?>
    , __2: Field<String?>
): Field<Ltree?> {
    val f = LtreeAddtext()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_cmp</code>
 */
fun ltreeCmp(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Int? {
    val f = LtreeCmp()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_cmp</code> as a field.
 */
fun ltreeCmp(
      __1: Ltree?
    , __2: Ltree?
): Field<Int?> {
    val f = LtreeCmp()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_cmp</code> as a field.
 */
fun ltreeCmp(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Int?> {
    val f = LtreeCmp()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeCompress(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtreeCompress()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeCompress(
      __1: Any?
): Field<Any?> {
    val f = LtreeCompress()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeCompress(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtreeCompress()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeConsistent(
      configuration: Configuration
    , __1: Any?
    , __2: Ltree?
    , __3: Short?
    , __4: Long?
    , __5: Any?
): Boolean? {
    val f = LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeConsistent(
      __1: Any?
    , __2: Ltree?
    , __3: Short?
    , __4: Long?
    , __5: Any?
): Field<Boolean?> {
    val f = LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeConsistent(
      __1: Field<Any?>
    , __2: Field<Ltree?>
    , __3: Field<Short?>
    , __4: Field<Long?>
    , __5: Field<Any?>
): Field<Boolean?> {
    val f = LtreeConsistent()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)
    f.set__5(__5)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeDecompress(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtreeDecompress()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeDecompress(
      __1: Any?
): Field<Any?> {
    val f = LtreeDecompress()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeDecompress(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtreeDecompress()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_eq</code>
 */
fun ltreeEq(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeEq()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_eq</code> as a field.
 */
fun ltreeEq(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeEq()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_eq</code> as a field.
 */
fun ltreeEq(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeEq()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_ge</code>
 */
fun ltreeGe(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeGe()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_ge</code> as a field.
 */
fun ltreeGe(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeGe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_ge</code> as a field.
 */
fun ltreeGe(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeGe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistIn(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtreeGistIn()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistIn(
      __1: Any?
): Field<Any?> {
    val f = LtreeGistIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistIn(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtreeGistIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistOptions(
      configuration: Configuration
    , __1: Any?
): Unit {
    val p = LtreeGistOptions()
    p.set__1(__1)

    p.execute(configuration)
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistOut(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtreeGistOut()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistOut(
      __1: Any?
): Field<Any?> {
    val f = LtreeGistOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeGistOut(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtreeGistOut()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_gt</code>
 */
fun ltreeGt(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeGt()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_gt</code> as a field.
 */
fun ltreeGt(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeGt()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_gt</code> as a field.
 */
fun ltreeGt(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeGt()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeIn(
      configuration: Configuration
    , __1: Any?
): Ltree? {
    val f = LtreeIn()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeIn(
      __1: Any?
): Field<Ltree?> {
    val f = LtreeIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeIn(
      __1: Field<Any?>
): Field<Ltree?> {
    val f = LtreeIn()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_isparent</code>
 */
fun ltreeIsparent(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_isparent</code> as a field.
 */
fun ltreeIsparent(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_isparent</code> as a field.
 */
fun ltreeIsparent(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeIsparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_le</code>
 */
fun ltreeLe(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeLe()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_le</code> as a field.
 */
fun ltreeLe(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeLe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_le</code> as a field.
 */
fun ltreeLe(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeLe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_lt</code>
 */
fun ltreeLt(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeLt()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_lt</code> as a field.
 */
fun ltreeLt(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeLt()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_lt</code> as a field.
 */
fun ltreeLt(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeLt()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.ltree_ne</code>
 */
fun ltreeNe(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeNe()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_ne</code> as a field.
 */
fun ltreeNe(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeNe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_ne</code> as a field.
 */
fun ltreeNe(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeNe()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeOut(
      configuration: Configuration
    , __1: Ltree?
): Any? {
    val f = LtreeOut()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeOut(
      __1: Ltree?
): Field<Any?> {
    val f = LtreeOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeOut(
      __1: Field<Ltree?>
): Field<Any?> {
    val f = LtreeOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePenalty(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
    , __3: Any?
): Any? {
    val f = LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePenalty(
      __1: Any?
    , __2: Any?
    , __3: Any?
): Field<Any?> {
    val f = LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePenalty(
      __1: Field<Any?>
    , __2: Field<Any?>
    , __3: Field<Any?>
): Field<Any?> {
    val f = LtreePenalty()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePicksplit(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
): Any? {
    val f = LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePicksplit(
      __1: Any?
    , __2: Any?
): Field<Any?> {
    val f = LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreePicksplit(
      __1: Field<Any?>
    , __2: Field<Any?>
): Field<Any?> {
    val f = LtreePicksplit()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeRecv(
      configuration: Configuration
    , __1: Any?
): Ltree? {
    val f = LtreeRecv()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeRecv(
      __1: Any?
): Field<Ltree?> {
    val f = LtreeRecv()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeRecv(
      __1: Field<Any?>
): Field<Ltree?> {
    val f = LtreeRecv()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_risparent</code>
 */
fun ltreeRisparent(
      configuration: Configuration
    , __1: Ltree?
    , __2: Ltree?
): Boolean? {
    val f = LtreeRisparent()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_risparent</code> as a field.
 */
fun ltreeRisparent(
      __1: Ltree?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtreeRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_risparent</code> as a field.
 */
fun ltreeRisparent(
      __1: Field<Ltree?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtreeRisparent()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeSame(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
    , __3: Any?
): Any? {
    val f = LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeSame(
      __1: Any?
    , __2: Any?
    , __3: Any?
): Field<Any?> {
    val f = LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeSame(
      __1: Field<Any?>
    , __2: Field<Any?>
    , __3: Field<Any?>
): Field<Any?> {
    val f = LtreeSame()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Call <code>public.ltree_send</code>
 */
fun ltreeSend(
      configuration: Configuration
    , __1: Ltree?
): ByteArray? {
    val f = LtreeSend()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_send</code> as a field.
 */
fun ltreeSend(
      __1: Ltree?
): Field<ByteArray?> {
    val f = LtreeSend()
    f.set__1(__1)

    return f.asField()
}

/**
 * Get <code>public.ltree_send</code> as a field.
 */
fun ltreeSend(
      __1: Field<Ltree?>
): Field<ByteArray?> {
    val f = LtreeSend()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.ltree_textadd</code>
 */
fun ltreeTextadd(
      configuration: Configuration
    , __1: String?
    , __2: Ltree?
): Ltree? {
    val f = LtreeTextadd()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.ltree_textadd</code> as a field.
 */
fun ltreeTextadd(
      __1: String?
    , __2: Ltree?
): Field<Ltree?> {
    val f = LtreeTextadd()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.ltree_textadd</code> as a field.
 */
fun ltreeTextadd(
      __1: Field<String?>
    , __2: Field<Ltree?>
): Field<Ltree?> {
    val f = LtreeTextadd()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeUnion(
      configuration: Configuration
    , __1: Any?
    , __2: Any?
): Any? {
    val f = LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeUnion(
      __1: Any?
    , __2: Any?
): Field<Any?> {
    val f = LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeUnion(
      __1: Field<Any?>
    , __2: Field<Any?>
): Field<Any?> {
    val f = LtreeUnion()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeparentsel(
      configuration: Configuration
    , __1: Any?
    , __2: Long?
    , __3: Any?
    , __4: Int?
): Double? {
    val f = Ltreeparentsel()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeparentsel(
      __1: Any?
    , __2: Long?
    , __3: Any?
    , __4: Int?
): Field<Double?> {
    val f = Ltreeparentsel()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltreeparentsel(
      __1: Field<Any?>
    , __2: Field<Long?>
    , __3: Field<Any?>
    , __4: Field<Int?>
): Field<Double?> {
    val f = Ltreeparentsel()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)
    f.set__4(__4)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqExec(
      configuration: Configuration
    , __1: Ltree?
    , __2: Any?
): Boolean? {
    val f = LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqExec(
      __1: Ltree?
    , __2: Any?
): Field<Boolean?> {
    val f = LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqExec(
      __1: Field<Ltree?>
    , __2: Field<Any?>
): Field<Boolean?> {
    val f = LtxtqExec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqIn(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtxtqIn()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqIn(
      __1: Any?
): Field<Any?> {
    val f = LtxtqIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqIn(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtxtqIn()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqOut(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtxtqOut()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqOut(
      __1: Any?
): Field<Any?> {
    val f = LtxtqOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqOut(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtxtqOut()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRecv(
      configuration: Configuration
    , __1: Any?
): Any? {
    val f = LtxtqRecv()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRecv(
      __1: Any?
): Field<Any?> {
    val f = LtxtqRecv()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRecv(
      __1: Field<Any?>
): Field<Any?> {
    val f = LtxtqRecv()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRexec(
      configuration: Configuration
    , __1: Any?
    , __2: Ltree?
): Boolean? {
    val f = LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRexec(
      __1: Any?
    , __2: Ltree?
): Field<Boolean?> {
    val f = LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqRexec(
      __1: Field<Any?>
    , __2: Field<Ltree?>
): Field<Boolean?> {
    val f = LtxtqRexec()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqSend(
      configuration: Configuration
    , __1: Any?
): ByteArray? {
    val f = LtxtqSend()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqSend(
      __1: Any?
): Field<ByteArray?> {
    val f = LtxtqSend()
    f.set__1(__1)

    return f.asField()
}
@Deprecated(message = "Unknown data type. Parameter type or return type is unknown. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
fun ltxtqSend(
      __1: Field<Any?>
): Field<ByteArray?> {
    val f = LtxtqSend()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.nlevel</code>
 */
fun nlevel(
      configuration: Configuration
    , __1: Ltree?
): Int? {
    val f = Nlevel()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.nlevel</code> as a field.
 */
fun nlevel(
      __1: Ltree?
): Field<Int?> {
    val f = Nlevel()
    f.set__1(__1)

    return f.asField()
}

/**
 * Get <code>public.nlevel</code> as a field.
 */
fun nlevel(
      __1: Field<Ltree?>
): Field<Int?> {
    val f = Nlevel()
    f.set__1(__1)

    return f.asField()
}

/**
 * Call <code>public.subltree</code>
 */
fun subltree(
      configuration: Configuration
    , __1: Ltree?
    , __2: Int?
    , __3: Int?
): Ltree? {
    val f = Subltree()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.subltree</code> as a field.
 */
fun subltree(
      __1: Ltree?
    , __2: Int?
    , __3: Int?
): Field<Ltree?> {
    val f = Subltree()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Get <code>public.subltree</code> as a field.
 */
fun subltree(
      __1: Field<Ltree?>
    , __2: Field<Int?>
    , __3: Field<Int?>
): Field<Ltree?> {
    val f = Subltree()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Call <code>public.subpath</code>
 */
fun subpath1(
      configuration: Configuration
    , __1: Ltree?
    , __2: Int?
    , __3: Int?
): Ltree? {
    val f = Subpath1()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.subpath</code> as a field.
 */
fun subpath1(
      __1: Ltree?
    , __2: Int?
    , __3: Int?
): Field<Ltree?> {
    val f = Subpath1()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Get <code>public.subpath</code> as a field.
 */
fun subpath1(
      __1: Field<Ltree?>
    , __2: Field<Int?>
    , __3: Field<Int?>
): Field<Ltree?> {
    val f = Subpath1()
    f.set__1(__1)
    f.set__2(__2)
    f.set__3(__3)

    return f.asField()
}

/**
 * Call <code>public.subpath</code>
 */
fun subpath2(
      configuration: Configuration
    , __1: Ltree?
    , __2: Int?
): Ltree? {
    val f = Subpath2()
    f.set__1(__1)
    f.set__2(__2)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.subpath</code> as a field.
 */
fun subpath2(
      __1: Ltree?
    , __2: Int?
): Field<Ltree?> {
    val f = Subpath2()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Get <code>public.subpath</code> as a field.
 */
fun subpath2(
      __1: Field<Ltree?>
    , __2: Field<Int?>
): Field<Ltree?> {
    val f = Subpath2()
    f.set__1(__1)
    f.set__2(__2)

    return f.asField()
}

/**
 * Call <code>public.text2ltree</code>
 */
fun text2ltree(
      configuration: Configuration
    , __1: String?
): Ltree? {
    val f = Text2ltree()
    f.set__1(__1)

    f.execute(configuration)
    return f.returnValue
}

/**
 * Get <code>public.text2ltree</code> as a field.
 */
fun text2ltree(
      __1: String?
): Field<Ltree?> {
    val f = Text2ltree()
    f.set__1(__1)

    return f.asField()
}

/**
 * Get <code>public.text2ltree</code> as a field.
 */
fun text2ltree(
      __1: Field<String?>
): Field<Ltree?> {
    val f = Text2ltree()
    f.set__1(__1)

    return f.asField()
}
